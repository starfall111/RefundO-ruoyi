# 两后端项目合并方案（修订版）

## 文档版本
- **版本**: v2.1
- **修订日期**: 2026-02-06
- **修订人**: Claude
- **修订内容**: 新增第6.7.9节"APP端用户上下文获取修改清单"，详细列出11个文件12处修改的具体位置和代码示例

---

## 一、项目现状对比

| 项目 | 管理系统 | APP端 |
|------|----------|-------|
| **Spring Boot** | 2.5.15 | 3.5.6 |
| **Java版本** | 1.8 | 17 |
| **包名** | com.refund | org.example.refundo |
| **模块数量** | 7个 | 3个 |
| **数据库连接池** | Druid | HikariCP |
| **JWT** | 0.9.1 | 0.11.5 |
| **国际化** | 中英 | 中英法 |
| **返回结果类** | AjaxResult | Result |

---

## 二、Spring版本降级方案

### 2.1 降级策略：APP端 → 管理系统版本

将APP端的 **Spring Boot 3.5.6 + Java 17** 降级到 **Spring Boot 2.5.15 + Java 1.8**

### 2.2 关键变更点

| 变更类型 | Spring Boot 3.x | Spring Boot 2.x |
|----------|-----------------|-----------------|
| **包名** | jakarta.* | javax.* |
| **Security配置** | SecurityFilterChain | WebSecurityConfigurerAdapter |
| **JWT库** | jjwt 0.11.5 | jjwt 0.9.1 |
| **MyBatis** | 3.0.3 | PageHelper 1.4.7 |

### 2.3 APP端需要降级修改的文件清单

```
需要降级修改的文件：
├── pom.xml（主POM）
├── common/pom.xml
├── server/pom.xml
├── server/src/main/java/org/example/refundo/Config/SecurityConfig.java ⭐核心
├── server/src/main/java/org/example/refundo/Filter/LocaleFilter.java
├── server/src/main/java/org/example/refundo/Filter/RateLimitFilter.java
├── common/src/main/java/org/example/refundo/Util/JwtAuthenticationFilter.java
└── 所有使用 jakarta.* 包的文件
```

---

## 三、工具类匹配与迁移方案

### 3.1 工具类迁移对照表

| APP端工具类 | 功能 | 迁移策略 |
|------------|------|----------|
| **AliOssUtil.java** | 阿里云OSS | ❌ **舍弃**，使用管理端 `OssUtil.java` |
| **EmailUtil.java** | 邮件发送 | ❌ **舍弃**，验证码功能整合到 `MailServiceImpl` |
| **HmacUtil.java** | HMAC加密 | ✅ **独立保留**，迁移到 `common/utils/sign/` |
| **JwtUtil.java** | JWT工具 | ❌ **舍弃**，使用管理端 `TokenService`（不同密钥） |
| **JwtAuthenticationFilter** | JWT过滤器 | ❌ **舍弃**，使用管理端 `JwtAuthenticationTokenFilter` |
| **numberGenUtils.java** | 数字生成 | ✅ 迁移到 `common/utils/uuid/` |
| **PasswordUtil.java** | 密码加密 | ✅ 迁移到 `common/utils/password/` |
| **RateLimitUtil.java** | 限流工具 | ✅ 迁移到 `common/utils/ratelimit/` |

### 3.2 工具类迁移结构

```
RefundO-common/src/main/java/com/refund/common/utils/
├── Aliyun/
│   └── OssUtil.java              # 保留现有（APP端使用此工具上传）
├── file/
│   └── FileUploadUtils.java      # 保留现有
├── sign/
│   ├── Md5Utils.java             # 保留现有
│   └── HmacUtil.java             # 新增：从APP端迁移（独立存在）
├── uuid/
│   ├── IdUtils.java              # 保留现有
│   └── NumberGenUtils.java       # 新增：从APP端迁移
├── password/
│   └── PasswordUtil.java         # 新增：从APP端迁移
├── ratelimit/
│   └── RateLimitUtil.java        # 新增：从APP端迁移
└── spring/
    └── SpringUtils.java          # 保留现有
```

### 3.3 HMAC与MD5工具类独立存在说明

**为什么HMAC和MD5需要独立存在？**

| 工具类 | 用途 | 算法 | 使用场景 |
|--------|------|------|----------|
| **Md5Utils** | 单向哈希 | MD5 | 密码加密、文件校验、数据摘要 |
| **HmacUtil** | 消息认证码 | HMAC-SHA256 | API签名、请求验证、防篡改 |

**两者区别**：
- MD5：不可逆，用于生成固定长度摘要
- HMAC：需要密钥，用于验证消息完整性和真实性

**独立保留方案**：
```
sign/
├── Md5Utils.java        # 现有，用于密码加密等
└── HmacUtil.java        # 新增，用于API签名验证
```

---

## 四、邮箱模块整合方案

### 4.1 邮件服务增强

**原APP端EmailUtil.java舍弃**，将验证码发送功能整合到管理系统的 `MailServiceImpl`

### 4.2 EmailTemplate扩展

**文件位置**: `RefundO-common/src/main/java/com/refund/common/core/domain/EmailTemplate.java`

```java
// 新增字段
public class EmailTemplate implements Serializable {
    // ... 现有字段 ...

    /**
     * 验证码（模板类型：4）
     */
    private String verificationCode;

    /**
     * 验证码过期分钟数
     */
    private Integer expireMinutes;

    // getter/setter...
}
```

### 4.3 IMailService接口扩展

**文件位置**: `RefundO-common/src/main/java/com/refund/common/service/IMailService.java`

```java
public interface IMailService {

    // ... 现有方法 ...

    /**
     * 发送验证码邮件
     *
     * @param toEmail 收件人邮箱
     * @param locale 语言环境（用于国际化邮件模板）
     * @return 验证码
     */
    String sendVerificationCodeEmail(String toEmail, Locale locale);
}
```

### 4.4 MailServiceImpl实现

**文件位置**: `RefundO-common/src/main/java/com/refund/common/service/impl/MailServiceImpl.java`

```java
@Service
public class MailServiceImpl implements IMailService {

    @Value("${verification.code.expire-minutes:3}")
    private int codeExpireMinutes;

    @Value("${verification.code.length:6}")
    private int codeLength;

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    /**
     * 发送验证码邮件（整合APP端功能）
     */
    @Async("mailExecutor")
    @Override
    public String sendVerificationCodeEmail(String toEmail, Locale locale) {
        // 生成验证码
        String verificationCode = generateVerificationCode();

        // 构建邮件内容（支持国际化）
        EmailTemplate template = new EmailTemplate();
        template.setToEmail(toEmail);
        template.setVerificationCode(verificationCode);
        template.setTemplateType(4); // 验证码类型
        template.setSubject(buildVerificationCodeSubject(locale));
        template.setContent(buildVerificationCodeContent(locale, verificationCode, codeExpireMinutes));

        // 发送邮件
        sendEmailAsync(template);

        // 存储到Redis（使用统一key前缀）
        String key = "verification_code:" + toEmail;
        redisTemplate.opsForValue().set(key, verificationCode,
            Duration.ofMinutes(codeExpireMinutes));

        log.info("Verification code email sent to: {}", toEmail);
        return verificationCode;
    }

    /**
     * 生成验证码
     */
    private String generateVerificationCode() {
        String format = "%0" + codeLength + "d";
        return String.format(format,
            ThreadLocalRandom.current().nextInt((int) Math.pow(10, codeLength)));
    }

    /**
     * 构建验证码邮件主题
     */
    private String buildVerificationCodeSubject(Locale locale) {
        if (locale.getLanguage().equals("zh")) {
            return "验证码 - Refund System";
        } else if (locale.getLanguage().equals("fr")) {
            return "Code de Vérification - Refund System";
        }
        return "Verification Code - Refund System"; // 默认英文
    }

    /**
     * 构建验证码邮件内容（仿照现有邮件模板风格）
     */
    private String buildVerificationCodeContent(Locale locale, String code, int minutes) {
        StringBuilderContent builder = StringBuilderContent.newBuilder();

        if (locale.getLanguage().equals("zh")) {
            return builder
                .appendLine("您好，")
                .appendLine("")
                .appendLine("您的验证码是: " + code)
                .appendLine("")
                .appendLine("请在 " + minutes + " 分钟内完成验证。")
                .appendLine("请勿将此验证码告知他人。")
                .appendLine("")
                .appendLine("如果您没有请求验证码，请忽略此邮件。")
                .appendLine("")
                .appendLine("祝好，")
                .appendLine("Refund Management Team")
                .build();
        } else if (locale.getLanguage().equals("fr")) {
            return builder
                .appendLine("Bonjour,")
                .appendLine("")
                .appendLine("Votre code de vérification est: " + code)
                .appendLine("")
                .appendLine("Veuillez compléter la vérification dans " + minutes + " minutes.")
                .appendLine("Ne partagez pas ce code avec d'autres.")
                .appendLine("")
                .appendLine("Si vous n'avez pas demandé ce code, veuillez ignorer cet e-mail.")
                .appendLine("")
                .appendLine("Cordialement,")
                .appendLine("Refund Management Team")
                .build();
        }

        // 英文默认
        return builder
            .appendLine("Hello,")
            .appendLine("")
            .appendLine("Your verification code is: " + code)
            .appendLine("")
            .appendLine("Please complete verification within " + minutes + " minutes.")
            .appendLine("Do not share this code with others.")
            .appendLine("")
            .appendLine("If you did not request a verification code, please ignore this email.")
            .appendLine("")
            .appendLine("Best regards,")
            .appendLine("Refund Management Team")
            .build();
    }
}
```

---

## 五、国际化方案（核心）

### 5.1 问题分析

**核心问题**：管理系统仅支持中英，APP端需要中英法，共用 `Accept-Language` 请求头会导致：
- APP端请求法文时，管理系统找不到对应语言文件
- 两端消息文本可能冲突

### 5.2 推荐方案：路径前缀 + 独立上下文

#### 方案架构

```
请求路径分类:
├── /api/*          → APP端请求（中英法三语言）
└── /* (其他)       → 管理系统请求（中英两语言）

国际化资源文件:
├── i18n/messages*.properties          → 管理系统（中英）
└── i18n/api-messages*.properties      → APP端（中英法）
```

#### 语言工具类设计

**1. 管理系统使用现有工具**

```java
// RefundO-common/src/main/java/com/refund/common/utils/MessageUtils.java
// 保持不变，使用 LocaleContextHolder
public static String message(String code, Object... args) {
    MessageSource messageSource = SpringUtils.getBean(MessageSource.class);
    return messageSource.getMessage(code, args, LocaleContextHolder.getLocale());
}
```

**2. APP端使用新增工具**

```java
// RefundO-common/src/main/java/com/refund/common/utils/ApiMessageUtils.java（新增）
package com.refund.common.utils;

import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import com.refund.common.utils.spring.SpringUtils;

/**
 * APP端国际化消息工具（独立上下文）
 *
 * @author refundo
 */
public class ApiMessageUtils {

    private static final String API_MESSAGE_BASE = "i18n/api-messages";

    /**
     * 获取APP端国际化消息
     */
    public static String message(String code, Object... args) {
        MessageSource messageSource = SpringUtils.getBean(API_MESSAGE_BASE, MessageSource.class);
        Locale locale = LocaleContextHolder.getLocale();
        return messageSource.getMessage(code, args, locale);
    }

    /**
     * 获取APP端国际化消息（指定Locale）
     */
    public static String message(String code, Locale locale, Object... args) {
        MessageSource messageSource = SpringUtils.getBean(API_MESSAGE_BASE, MessageSource.class);
        return messageSource.getMessage(code, args, locale);
    }
}
```

### 5.3 国际化配置类

**1. 管理系统MessageSource配置（保持不变）**

```java
// RefundO-framework/src/main/java/com/refund/framework/config/I18nConfig.java
@Configuration
public class I18nConfig {

    @Bean
    public MessageSource messageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasenames("i18n/messages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setCacheSeconds(3600);
        return messageSource;
    }
}
```

**2. APP端MessageSource配置（新增）**

```java
// RefundO-framework/src/main/java/com/refund/framework/config/ApiI18nConfig.java（新增）
package com.refund.framework.config;

import org.springframework.context.MessageSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.ResourceBundleMessageSource;

/**
 * APP端国际化配置
 */
@Configuration
public class ApiI18nConfig {

    @Bean("api-messages")
    public MessageSource apiMessageSource() {
        ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
        messageSource.setBasenames("i18n/api-messages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setCacheSeconds(3600);
        return messageSource;
    }
}
```

### 5.4 国际化过滤器整合方案

**核心思路**：通过请求路径前缀自动选择对应的MessageSource

```java
// RefundO-framework/src/main/java/com/refund/framework/config/HeaderLocaleResolver.java（修改）
package com.refund.framework.config;

import java.util.Locale;
import javax.servlet.http.HttpServletRequest;
import org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver;

/**
 * 语言解析器（增强版）
 */
public class HeaderLocaleResolver extends AcceptHeaderLocaleResolver {

    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        String requestUri = request.getRequestURI();

        // APP端请求：支持中英法
        if (requestUri.startsWith("/api/")) {
            String acceptLanguage = request.getHeader("Accept-Language");

            // 支持的语言
            if (acceptLanguage != null) {
                if (acceptLanguage.contains("zh") || acceptLanguage.contains("ZH")) {
                    return Locale.SIMPLIFIED_CHINESE;
                } else if (acceptLanguage.contains("fr") || acceptLanguage.contains("FR")) {
                    return Locale.FRENCH;
                }
            }
            return Locale.ENGLISH; // 默认英文
        }

        // 管理系统请求：仅支持中英
        String acceptLanguage = request.getHeader("Accept-Language");
        if (acceptLanguage != null && acceptLanguage.contains("zh")) {
            return Locale.SIMPLIFIED_CHINESE;
        }
        return Locale.ENGLISH;
    }
}
```

### 5.5 国际化文件结构

```
RefundO-admin/src/main/resources/i18n/
├── messages.properties              # 管理系统-默认
├── messages_zh.properties           # 管理系统-中文
├── messages_en.properties           # 管理系统-英文
├── api-messages.properties          # APP端-默认
├── api-messages_zh.properties       # APP端-中文
├── api-messages_en.properties       # APP端-英文
└── api-messages_fr.properties       # APP端-法文
```

### 5.6 使用示例

```java
// 管理系统Controller
@RestController
@RequestMapping("/system/user")
public class SysUserController {
    public AjaxResult getUser() {
        // 使用 MessageUtils
        String msg = MessageUtils.message("user.not.exists");
        return AjaxResult.error(msg);
    }
}

// APP端Controller
@RestController
@RequestMapping("/api/user")
public class ApiUserController {
    public Result<?> getUser() {
        // 使用 ApiMessageUtils
        String msg = ApiMessageUtils.message("error.account.not.found");
        return Result.error(msg);
    }
}
```

---

## 六、JWT令牌方案

### 6.1 JWT策略

| 项目 | 令牌服务 | 密钥 | 存储位置 | 过期时间 |
|------|----------|------|----------|----------|
| **管理系统** | TokenService | token.secret | `login_token:{uuid}` | 30分钟 |
| **APP端** | ApiTokenService | api.token.secret | `api_login_token:{uuid}` | 24小时 |

### 6.2 ApiTokenService设计（新增）

**文件位置**: `RefundO-framework/src/main/java/com/refund/framework/web/service/ApiTokenService.java`

```java
package com.refund.framework.web.service;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import javax.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import com.refund.common.constant.CacheConstants;
import com.refund.common.core.domain.model.ApiLoginUser;
import com.refund.common.core.redis.RedisCache;
import com.refund.common.utils.ServletUtils;
import com.refund.common.utils.StringUtils;
import com.refund.common.utils.uuid.IdUtils;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;

/**
 * APP端 Token验证处理
 */
@Component
public class ApiTokenService {

    @Value("${api.token.header:Authorization}")
    private String header;

    @Value("${api.token.secret:abcdefghijklmnopqrstuvwxyz1234567890}")
    private String secret;

    @Value("${api.token.expireTime:1440}")  // 24小时 = 1440分钟
    private int expireTime;

    @Autowired
    private RedisCache redisCache;

    private static final long MILLIS_SECOND = 1000;
    private static final long MILLIS_MINUTE = 60 * MILLIS_SECOND;
    private static final Long MILLIS_MINUTE_TEN = 10 * 60 * 1000L;

    /**
     * 获取APP端用户身份信息
     */
    public ApiLoginUser getLoginUser(HttpServletRequest request) {
        String token = getToken(request);
        if (StringUtils.isNotEmpty(token)) {
            try {
                Claims claims = parseToken(token);
                String uuid = (String) claims.get(Constants.API_LOGIN_USER_KEY);
                String userKey = getTokenKey(uuid);
                ApiLoginUser user = redisCache.getCacheObject(userKey);
                return user;
            } catch (Exception e) {
                // log error
            }
        }
        return null;
    }

    /**
     * 创建APP端令牌
     */
    public String createToken(ApiLoginUser loginUser) {
        String token = IdUtils.fastUUID();
        loginUser.setToken(token);
        refreshToken(loginUser);

        Map<String, Object> claims = new HashMap<>();
        claims.put(Constants.API_LOGIN_USER_KEY, token);
        return createToken(claims);
    }

    /**
     * 验证令牌有效期
     */
    public void verifyToken(ApiLoginUser loginUser) {
        long expireTime = loginUser.getExpireTime();
        long currentTime = System.currentTimeMillis();
        if (expireTime - currentTime <= MILLIS_MINUTE_TEN) {
            refreshToken(loginUser);
        }
    }

    /**
     * 刷新令牌有效期
     */
    private void refreshToken(ApiLoginUser loginUser) {
        loginUser.setLoginTime(System.currentTimeMillis());
        loginUser.setExpireTime(loginUser.getLoginTime() + expireTime * MILLIS_MINUTE);
        String userKey = getTokenKey(loginUser.getToken());
        redisCache.setCacheObject(userKey, loginUser, expireTime, TimeUnit.MINUTES);
    }

    private String createToken(Map<String, Object> claims) {
        return Jwts.builder()
                .setClaims(claims)
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }

    private Claims parseToken(String token) {
        return Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token)
                .getBody();
    }

    private String getToken(HttpServletRequest request) {
        String token = request.getHeader(header);
        if (StringUtils.isNotEmpty(token) && token.startsWith(Constants.TOKEN_PREFIX)) {
            token = token.replace(Constants.TOKEN_PREFIX, "");
        }
        return token;
    }

    private String getTokenKey(String uuid) {
        return CacheConstants.API_LOGIN_TOKEN_KEY + uuid;
    }
}
```

### 6.3 ApiLoginUser设计（新增）

**文件位置**: `RefundO-common/src/main/java/com/refund/common/core/domain/model/ApiLoginUser.java`

```java
package com.refund.common.core.domain.model;

import java.io.Serializable;
import java.util.Date;

/**
 * APP端登录用户身份信息
 */
public class ApiLoginUser implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long userId;
    private String username;
    private String email;
    private String token;
    private Long loginTime;
    private Long expireTime;
    private String ipaddr;
    private String loginLocation;

    // getter/setter...
}
```

### 6.4 ApiJwtAuthenticationFilter（新增）

**文件位置**: `RefundO-framework/src/main/java/com/refund/framework/security/filter/ApiJwtAuthenticationFilter.java`

```java
package com.refund.framework.security.filter;

import java.io.IOException;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import com.refund.common.core.domain.model.ApiLoginUser;
import com.refund.common.utils.StringUtils;
import com.refund.framework.web.service.ApiTokenService;

/**
 * APP端 Token过滤器
 * 仅处理 /api/* 路径的请求
 */
@Component
public class ApiJwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private ApiTokenService apiTokenService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain)
            throws ServletException, IOException {

        String requestUri = request.getRequestURI();

        // 仅处理APP端请求
        if (requestUri.startsWith("/api/")) {
            ApiLoginUser loginUser = apiTokenService.getLoginUser(request);
            if (StringUtils.isNotNull(loginUser) &&
                StringUtils.isNull(SecurityContextHolder.getContext().getAuthentication())) {

                apiTokenService.verifyToken(loginUser);
                UsernamePasswordAuthenticationToken authenticationToken =
                    new UsernamePasswordAuthenticationToken(loginUser, null, null);
                authenticationToken.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authenticationToken);
            }
        }

        chain.doFilter(request, response);
    }
}
```

### 6.5 配置文件扩展

**application.yml** 新增：

```yaml
# ========== APP端 Token配置 ==========
api:
  token:
    header: Authorization
    secret: abcdefghijklmnopqrstuvwxyz1234567890  # 与管理系统不同
    expireTime: 1440  # 24小时（单位：分钟）

# ========== 管理系统 Token配置（现有） ==========
token:
  header: Authorization
  secret: abcdefghijklmnopqrstuvwxyz1234567890
  expireTime: 30
```

### 6.6 常量扩展

**CacheConstants** 新增：

```java
public class CacheConstants {
    // ... 现有常量 ...

    /**
     * APP端登录用户 Redis Key
     */
    public static final String API_LOGIN_TOKEN_KEY = "api_login_token:";
}
```

**Constants** 新增：

```java
public class Constants {
    // ... 现有常量 ...

    /**
     * APP端登录用户 Key
     */
    public static final String API_LOGIN_USER_KEY = "api_login_user_key";
}
```

### 6.7 JWT上下文关系详解（核心）

本节详细说明管理系统和APP端用户登录的上下文关系、存储结构和隔离机制。

#### 6.7.1 用户实体对比

| 属性 | LoginUser（管理系统） | ApiLoginUser（APP端） |
|------|---------------------|---------------------|
| **用户信息** | 包含完整SysUser对象 | 仅包含基础用户信息 |
| **部门ID** | ✅ 有（deptId） | ❌ 无 |
| **权限列表** | ✅ 有（permissions Set） | ❌ 无（APP端无权限系统） |
| **角色信息** | ✅ 有（通过SysUser.getRoles()） | ❌ 无 |
| **浏览器信息** | ✅ 有（browser, os） | ❌ 无（移动端不需要） |
| **登录位置** | ✅ 有（loginLocation） | ✅ 有 |
| **Token过期时间** | 30分钟 | 24小时 |
| **主要用途** | 管理后台权限控制 | 移动端身份验证 |

**LoginUser（管理系统）结构**：

```java
public class LoginUser implements UserDetails {
    private Long userId;           // 用户ID
    private Long deptId;           // 部门ID
    private String token;          // 令牌UUID
    private Long loginTime;        // 登录时间
    private Long expireTime;       // 过期时间
    private String ipaddr;         // 登录IP
    private String loginLocation;  // 登录地点
    private String browser;        // 浏览器类型
    private String os;             // 操作系统
    private Set<String> permissions; // 权限列表
    private SysUser user;          // 完整用户对象（包含角色）
}
```

**ApiLoginUser（APP端）结构**：

```java
public class ApiLoginUser implements Serializable {
    private Long userId;           // 用户ID
    private String username;       // 用户名
    private String email;          // 邮箱
    private String token;          // 令牌UUID
    private Long loginTime;        // 登录时间
    private Long expireTime;       // 过期时间
    private String ipaddr;         // 登录IP
    private String loginLocation;  // 登录地点
    // 不包含部门、权限、角色等信息（精简设计）
}
```

#### 6.7.2 Redis存储结构对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          Redis 存储结构对比                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  管理系统用户登录:                                                           │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Key:   login_token:abc123def456...                                  │   │
│  │ Value: LoginUser对象（JSON序列化）                                    │   │
│  │         {                                                           │   │
│  │           "userId": 1,                                              │   │
│  │           "deptId": 103,                                            │   │
│  │           "token": "abc123def456...",                               │   │
│  │           "user": { "userName": "admin", "roles": [...] },         │   │
│  │           "permissions": ["*:*:*", "system:user:list"],             │   │
│  │           "loginTime": 1736179200000,                               │   │
│  │           "expireTime": 1736181000000                               │   │
│  │         }                                                           │   │
│  │ TTL:   30分钟（1800秒）                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  APP端用户登录:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Key:   api_login_token:xyz789uvw012...                              │   │
│  │ Value: ApiLoginUser对象（JSON序列化）                                 │   │
│  │         {                                                           │   │
│  │           "userId": 100,                                            │   │
│  │           "username": "user@example.com",                           │   │
│  │           "email": "user@example.com",                              │   │
│  │           "token": "xyz789uvw012...",                               │   │
│  │           "loginTime": 1736179200000,                               │   │
│  │           "expireTime": 1736265600000  (24小时后)                     │   │
│  │         }                                                           │   │
│  │ TTL:   24小时（86400秒）                                              │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键差异**：
1. **Key前缀不同**：`login_token:` vs `api_login_token:`
2. **存储内容不同**：LoginUser包含完整权限信息，ApiLoginUser仅包含基础信息
3. **过期时间不同**：30分钟 vs 24小时

#### 6.7.3 JWT Token结构对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          JWT Token 结构对比                                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  管理系统 JWT Token:                                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Header:  {"alg": "HS512", "typ": "JWT"}                             │   │
│  │ Payload: {                                                          │   │
│  │            "login_user_key": "abc123def456...",  # Redis Key的UUID  │   │
│  │            "username": "admin"                                      │   │
│  │          }                                                          │   │
│  │ Signature: 使用 token.secret 签名                                      │   │
│  │ 完整Token: Bearer eyJhbGciOiJIUzUxMiJ9...                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  APP端 JWT Token:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ Header:  {"alg": "HS512", "typ": "JWT"}                             │   │
│  │ Payload: {                                                          │   │
│  │            "api_login_user_key": "xyz789uvw012..."  # Redis Key的UUID│   │
│  │          }                                                          │   │
│  │ Signature: 使用 api.token.secret 签名（与管理系统不同）                  │   │
│  │ 完整Token: Bearer eyJhbGciOiJIUzUxMiJ9...                            │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

**关键差异**：
1. **Payload中的Key不同**：`login_user_key` vs `api_login_user_key`
2. **签名密钥不同**：使用不同的secret，两端Token无法互相解析
3. **Payload内容**：管理系统包含username，APP端仅包含UUID

#### 6.7.4 请求处理流程中的上下文切换

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         请求处理与上下文设置流程                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  第一步：请求进入过滤器链                                                      │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 请求: GET /api/user/profile                                         │   │
│  │      Header: Authorization: Bearer xxxxx                            │   │
│  │             Accept-Language: zh-CN                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                              │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第二步：LocaleFilter（Order=1）                                      │   │
│  │ - 解析 Accept-Language: zh-CN                                       │   │
│  │ - 设置到 LocaleContextHolder.getLocale() = Locale.CHINA             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                              │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第三步：RateLimitFilter（Order=2，仅/api/*）                          │   │
│  │ - 检查IP限流                                                         │   │
│  │ - 检查用户限流                                                       │   │
│  │ - 通过后继续                                                         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                              │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第四步：路径判断                                                     │   │
│  │                                                                     │   │
│  │   请求URI: /api/user/profile                                        │   │
│  │   判断: startsWith("/api/") → TRUE                                  │   │
│  │                                                                     │   │
│  │   → 激活 APP端处理流程                                               │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                              │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第五步：ApiJwtAuthenticationFilter                                   │   │
│  │                                                                     │   │
│  │ 1. 提取Token: Bearer xxxxx → "xxxxx"                                │   │
│  │ 2. 解析JWT（使用api.token.secret）:                                  │   │
│  │    - 获取 api_login_user_key = "xyz789..."                          │   │
│  │ 3. 从Redis获取用户信息:                                              │   │
│  │    - Key: api_login_token:xyz789...                                 │   │
│  │    - Value: ApiLoginUser{userId=100, username="user@example.com"}   │   │
│  │ 4. 验证Token有效期                                                   │   │
│  │ 5. 设置到SecurityContext:                                           │   │
│  │    SecurityContextHolder.getContext().setAuthentication(             │   │
│  │      new UsernamePasswordAuthenticationToken(                       │   │
│  │        apiLoginUser,  // Principal                                   │   │
│  │        null,         // Credentials                                  │   │
│  │        null          // Authorities（APP端无权限）                    │   │
│  │      )                                                                 │   │
│  │    )                                                                  │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                              │                                              │
│                              ▼                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 第六步：Controller处理                                               │   │
│  │                                                                     │   │
│  │ @RestController                                                     │   │
│  │ @RequestMapping("/api/user")                                        │   │
│  │ public class ApiUserController {                                    │   │
│  │                                                                     │   │
│  │     @GetMapping("/profile")                                         │   │
│  │     public Result<?> getProfile() {                                 │   │
│  │         // 方式1：通过SecurityUtils获取                               │   │
│  │         Long userId = SecurityUtils.getUserId();  // ❌ 会报错！     │   │
│  │         // 因为SecurityUtils期望的是LoginUser，实际是ApiLoginUser    │   │
│  │                                                                     │   │
│  │         // 方式2：通过ApiSecurityUtils获取（正确方式）                   │   │
│  │         Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确     │   │
│  │                                                                     │   │
│  │         // 方式3：直接从SecurityContext获取                          │   │
│  │         Authentication auth = SecurityContextHolder                 │   │
│  │             .getContext().getAuthentication();                      │   │
│  │         if (auth.getPrincipal() instanceof ApiLoginUser) {          │   │
│  │             ApiLoginUser user = (ApiLoginUser) auth.getPrincipal();│   │
│  │             Long userId = user.getUserId();                         │   │
│  │         }                                                           │   │
│  │     }                                                               │   │
│  │ }                                                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 6.7.5 工具类获取用户对比

**管理系统Controller**：

```java
@RestController
@RequestMapping("/system/user")
public class SysUserController {

    @GetMapping("/profile")
    public AjaxResult getProfile() {
        // ✅ 使用 SecurityUtils 获取管理系统用户
        Long userId = SecurityUtils.getUserId();
        String username = SecurityUtils.getUsername();
        LoginUser loginUser = SecurityUtils.getLoginUser();

        // 获取权限
        boolean hasPermi = SecurityUtils.hasPermi("system:user:add");

        return AjaxResult.success(loginUser);
    }
}
```

**APP端Controller**：

```java
@RestController
@RequestMapping("/api/user")
public class ApiUserController {

    @GetMapping("/profile")
    public Result<?> getProfile() {
        // ❌ 错误：SecurityUtils期望LoginUser，实际是ApiLoginUser
        // Long userId = SecurityUtils.getUserId();  // 会抛出异常

        // ✅ 正确：使用ApiSecurityUtils获取APP端用户
        Long userId = ApiSecurityUtils.getUserId();
        String username = ApiSecurityUtils.getUsername();
        ApiLoginUser loginUser = ApiSecurityUtils.getLoginUser();

        return Result.success(loginUser);
    }
}
```

#### 6.7.6 ApiSecurityUtils工具类（新增）

**文件位置**: `RefundO-common/src/main/java/com/refund/common/utils/ApiSecurityUtils.java`

```java
package com.refund.common.utils;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import com.refund.common.constant.HttpStatus;
import com.refund.common.core.domain.model.ApiLoginUser;
import com.refund.common.exception.ServiceException;

/**
 * APP端安全服务工具类
 *
 * @author refundo
 */
public class ApiSecurityUtils {

    /**
     * 获取APP端用户ID
     */
    public static Long getUserId() {
        try {
            return getLoginUser().getUserId();
        } catch (Exception e) {
            throw new ServiceException("获取用户ID异常", HttpStatus.UNAUTHORIZED);
        }
    }

    /**
     * 获取APP端用户名
     */
    public static String getUsername() {
        try {
            return getLoginUser().getUsername();
        } catch (Exception e) {
            throw new ServiceException("获取用户名异常", HttpStatus.UNAUTHORIZED);
        }
    }

    /**
     * 获取APP端邮箱
     */
    public static String getEmail() {
        try {
            return getLoginUser().getEmail();
        } catch (Exception e) {
            throw new ServiceException("获取邮箱异常", HttpStatus.UNAUTHORIZED);
        }
    }

    /**
     * 获取APP端登录用户
     */
    public static ApiLoginUser getLoginUser() {
        try {
            Authentication authentication = getAuthentication();
            Object principal = authentication.getPrincipal();

            // 验证类型
            if (principal instanceof ApiLoginUser) {
                return (ApiLoginUser) principal;
            }

            throw new ServiceException("用户类型错误：期望ApiLoginUser", HttpStatus.UNAUTHORIZED);
        } catch (Exception e) {
            throw new ServiceException("获取用户信息异常", HttpStatus.UNAUTHORIZED);
        }
    }

    /**
     * 获取Authentication
     */
    public static Authentication getAuthentication() {
        return SecurityContextHolder.getContext().getAuthentication();
    }

    /**
     * 判断当前是否为APP端请求
     */
    public static boolean isApiRequest() {
        Authentication auth = getAuthentication();
        return auth != null && auth.getPrincipal() instanceof ApiLoginUser;
    }
}
```

#### 6.7.7 上下文隔离机制总结

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         上下文隔离机制                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  隔离维度                     管理系统               APP端                    │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  请求路径前缀                 /system/*,            /api/*                    │
│                              /monitor/*,                                    │
│                              /*                                             │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  Redis Key前缀               login_token:          api_login_token:          │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  JWT Payload Key             login_user_key        api_login_user_key        │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  签名密钥                     token.secret          api.token.secret          │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  用户实体                     LoginUser             ApiLoginUser               │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  Token过期时间                30分钟                24小时                     │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  过滤器                       JwtAuthentication     ApiJwtAuthentication      │
│                              TokenFilter           Filter                    │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  工具类                       SecurityUtils         ApiSecurityUtils          │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  权限控制                     ✅ 有                 ❌ 无                      │
│  ─────────────────────────  ─────────────────     ─────────────────         │
│  国际化工具                   MessageUtils          ApiMessageUtils           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 6.7.8 完整登录流程对比

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         完整登录流程对比                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  管理系统登录流程:                                                            │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. 请求: POST /login                                                │   │
│  │    Body: { "username": "admin", "password": "xxx", "code": "1234" } │   │
│  │                                                                     │   │
│  │ 2. SysLoginService.login()                                          │   │
│  │    - 验证用户名密码                                                  │   │
│  │    - 验证验证码                                                      │   │
│  │    - 查询用户完整信息（部门、角色、权限）                              │   │
│  │    - 创建LoginUser对象                                               │   │
│  │                                                                     │   │
│  │ 3. TokenService.createToken(loginUser)                              │   │
│  │    - 生成UUID: "abc123..."                                          │   │
│  │    - 存储Redis: login_token:abc123... → LoginUser                    │   │
│  │    - 生成JWT: { "login_user_key": "abc123..." }                     │   │
│  │    - 返回Token                                                       │   │
│  │                                                                     │   │
│  │ 4. 响应: { "code": 200, "token": "Bearer xxxxx" }                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
│  APP端登录流程:                                                              │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │ 1. 请求: POST /api/user/login                                        │   │
│  │    Body: { "email": "user@ex.com", "password": "xxx" }              │   │
│  │                                                                     │   │
│  │ 2. ApiLoginService.login()                                          │   │
│  │    - 验证邮箱密码                                                    │   │
│  │    - 查询用户基础信息                                                │   │
│  │    - 创建ApiLoginUser对象（精简）                                    │   │
│  │                                                                     │   │
│  │ 3. ApiTokenService.createToken(apiLoginUser)                        │   │
│  │    - 生成UUID: "xyz789..."                                          │   │
│  │    - 存储Redis: api_login_token:xyz789... → ApiLoginUser             │   │
│  │    - 生成JWT: { "api_login_user_key": "xyz789..." }                 │   │
│  │    - 返回Token                                                       │   │
│  │                                                                     │   │
│  │ 4. 响应: { "code": 1, "data": { "token": "Bearer xxxxx" } }         │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 6.7.9 APP端用户上下文获取修改清单

本节详细列出APP端代码中需要修改用户上下文获取的具体位置和修改方式。

##### 6.7.9.1 核心替换映射

| 当前实现 | 需要替换为 | 说明 |
|---------|-----------|------|
| `BaseContext.getCurrentId()` | `ApiSecurityUtils.getUserId()` | 获取当前用户ID |
| `JwtUtil.generateToken(userId)` | `ApiTokenService.createToken(apiLoginUser)` | 生成Token |
| 自定义 `JwtAuthenticationFilter` | `ApiJwtAuthenticationFilter` | JWT认证过滤器 |
| 自定义 `SecurityConfig` | 统一 `SecurityConfig` | 安全配置 |

##### 6.7.9.2 需要修改的文件分类

**1. 基础设施层（4个文件）**

| 文件 | 修改类型 | 说明 |
|------|----------|------|
| `common/.../Util/JwtUtil.java` | ❌ 舍弃 | 替换为ApiTokenService |
| `common/.../Util/JwtAuthenticationFilter.java` | ❌ 舍弃 | 替换为ApiJwtAuthenticationFilter |
| `common/.../Context/BaseContext.java` | ❌ 舍弃 | 替换为ApiSecurityUtils |
| `server/.../Config/SecurityConfig.java` | 🔧 修改 | 合并到统一SecurityConfig |

**2. Controller层（2个文件）**

| 文件 | 修改行号 | 修改内容 |
|------|----------|----------|
| `UserController.java` | 48 | `JwtUtil.generateToken()` → `ApiTokenService.createToken()` |
| `IllegalController.java` | 26 | `BaseContext.getCurrentId()` → `ApiSecurityUtils.getUserId()` |

**3. Service实现层（4个文件，共12处修改）**

| 文件 | 修改行号 | 修改次数 |
|------|----------|----------|
| `UserServiceImpl.java` | 163, 181, 229 | 3处 |
| `RefundRequestServiceImpl.java` | 55, 92, 103, 128 | 4处 |
| `ScanServiceImpl.java` | 47, 101 | 2处 |
| `FeedBackServiceImpl.java` | 22, 38, 50 | 3处 |

**4. 切面层（1个文件）**

| 文件 | 修改行号 | 修改内容 |
|------|----------|----------|
| `RateLimitAspect.java` | 83 | `BaseContext.getCurrentId()` → `ApiSecurityUtils.getUserId()` |

##### 6.7.9.3 具体修改示例

**1. UserServiceImpl.java 修改（3处）**

```java
// 修改前
package org.example.refundo.Service.Impl;

public class UserServiceImpl implements UserService {

    @Override
    public User getUserById() {
        Long uid = BaseContext.getCurrentId();  // ❌ 需要修改
        return userMapper.selectById(uid);
    }

    @Override
    public User updateUser(UserUpdateDTO userUpdate) {
        Long uid = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }

    @Override
    public void updatePassword(String newPassword) {
        Long uid = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }

    @Override
    public void logout(HttpServletRequest request) {
        // ...
        BaseContext.clear();  // ❌ 需要删除（ApiSecurityUtils无需清理）
    }
}

// 修改后
package com.refund.web.service.impl;  // 包名修改

import com.refund.common.utils.ApiSecurityUtils;  // 新增导入

public class ApiUserServiceImpl implements ApiUserService {

    @Autowired
    private ApiTokenService apiTokenService;  // 新增注入

    @Override
    public User getUserById() {
        Long uid = ApiSecurityUtils.getUserId();  // ✅ 正确
        return userMapper.selectById(uid);
    }

    @Override
    public User updateUser(UserUpdateDTO userUpdate) {
        Long uid = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }

    @Override
    public void updatePassword(String newPassword) {
        Long uid = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }

    @Override
    public void logout(HttpServletRequest request) {
        // 使用ApiTokenService删除Redis中的token
        apiTokenService.delLoginUser(request);
        // 不再需要BaseContext.clear()
    }
}
```

**2. RefundRequestServiceImpl.java 修改（4处）**

```java
// 修改前
package org.example.refundo.Service.Impl;

public class RefundRequestServiceImpl implements RefundRequestService {

    @Override
    public PageResult<RefundRequest> getRequestsByCurrentUserPage(PageQueryDTO pageQuery) {
        Long userId = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }

    @Override
    public RefundRequest createRefundRequest(Long scanId, String reason) {
        // ...
        Long userId = BaseContext.getCurrentId();  // ❌ 需要修改（第92行）
        // ...
    }

    // 第103行、128行类似修改...
}

// 修改后
package com.refund.web.service.impl;

import com.refund.common.utils.ApiSecurityUtils;

public class ApiRefundRequestServiceImpl implements ApiRefundRequestService {

    @Override
    public PageResult<RefundRequest> getRequestsByCurrentUserPage(PageQueryDTO pageQuery) {
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }

    @Override
    public RefundRequest createRefundRequest(Long scanId, String reason) {
        // ...
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }
}
```

**3. ScanServiceImpl.java 修改（2处）**

```java
// 修改前
public class ScanServiceImpl implements ScanService {

    @Override
    public PageResult<ScanRecordsVO> getScansByUserIdPage(PageQueryDTO pageQuery) {
        Long userId = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }

    @Override
    public void addScanRecord(Product product) {
        Long userId = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }
}

// 修改后
import com.refund.common.utils.ApiSecurityUtils;

public class ApiScanServiceImpl implements ApiScanService {

    @Override
    public PageResult<ScanRecordsVO> getScansByUserIdPage(PageQueryDTO pageQuery) {
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }

    @Override
    public void addScanRecord(Product product) {
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }
}
```

**4. FeedBackServiceImpl.java 修改（3处）**

```java
// 修改前
public class FeedBackServiceImpl implements FeedBackService {

    @Override
    public void submitFeedback(String content, Integer rating) {
        Long userId = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }

    @Override
    public List<FeedBack> getUserFeedbacks() {
        Long userId = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }

    @Override
    public void withdrawFeedback(Long feedbackId) {
        Long userId = BaseContext.getCurrentId();  // ❌ 需要修改
        // ...
    }
}

// 修改后
import com.refund.common.utils.ApiSecurityUtils;

public class ApiFeedBackServiceImpl implements ApiFeedBackService {

    @Override
    public void submitFeedback(String content, Integer rating) {
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }

    @Override
    public List<FeedBack> getUserFeedbacks() {
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }

    @Override
    public void withdrawFeedback(Long feedbackId) {
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        // ...
    }
}
```

**5. UserController.java 修改（1处）**

```java
// 修改前
package org.example.refundo.Controller;

import org.example.refundo.Util.JwtUtil;  // ❌ 需要修改

@RestController
@RequestMapping("/user")
public class UserController {

    @PostMapping("/login")
    public Result<?> login(@RequestBody LoginDTO loginDTO) {
        // 验证用户...
        User user = userService.login(loginDTO);

        // 生成Token
        String token = JwtUtil.generateToken(user.getId());  // ❌ 需要修改

        return Result.success(Map.of("token", "Bearer " + token));
    }
}

// 修改后
package com.refund.web.controller;

import com.refund.common.core.domain.model.ApiLoginUser;
import com.refund.framework.web.service.ApiTokenService;  // ✅ 新增

@RestController
@RequestMapping("/api/user")  // 路径前缀修改
public class ApiUserController {

    @Autowired
    private ApiTokenService apiTokenService;

    @PostMapping("/login")
    public Result<?> login(@RequestBody LoginDTO loginDTO) {
        // 验证用户...
        User user = apiUserService.login(loginDTO);

        // 构建ApiLoginUser
        ApiLoginUser apiLoginUser = new ApiLoginUser();
        apiLoginUser.setUserId(user.getId());
        apiLoginUser.setUsername(user.getEmail());
        apiLoginUser.setEmail(user.getEmail());
        apiLoginUser.setIpaddr(ServletUtils.getClientIP());

        // 生成Token
        String token = apiTokenService.createToken(apiLoginUser);  // ✅ 正确

        return Result.success(Map.of("token", "Bearer " + token));
    }
}
```

**6. IllegalController.java 修改（1处）**

```java
// 修改前
package org.example.refundo.Controller;

@RestController
@RequestMapping("/illegal")
public class IllegalController {

    @GetMapping("/list")
    public Result<List<Illegal>> getIllegalRecords() {
        Long userId = org.example.refundo.Context.BaseContext.getCurrentId();  // ❌ 需要修改
        return Result.success(illegalService.getByUserId(userId));
    }
}

// 修改后
package com.refund.web.controller;

import com.refund.common.utils.ApiSecurityUtils;  // ✅ 新增

@RestController
@RequestMapping("/api/illegal")  // 路径前缀修改
public class ApiIllegalController {

    @GetMapping("/list")
    public Result<List<Illegal>> getIllegalRecords() {
        Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
        return Result.success(illegalService.getByUserId(userId));
    }
}
```

**7. RateLimitAspect.java 修改（1处）**

```java
// 修改前
package org.example.refundo.Aspect;

import org.example.refundo.Context.BaseContext;  // ❌ 需要修改

@Aspect
@Component
public class RateLimitAspect {

    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        // ...

        switch (rateLimit.limitType()) {
            case USER:
                Long userId = BaseContext.getCurrentId();  // ❌ 需要修改
                // 限流逻辑...
                break;
            // ...
        }
    }
}

// 修改后
package com.refund.framework.aspectj;

import com.refund.common.utils.ApiSecurityUtils;  // ✅ 新增

@Aspect
@Component
public class ApiRateLimitAspect {

    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        // ...

        switch (rateLimit.limitType()) {
            case USER:
                Long userId = ApiSecurityUtils.getUserId();  // ✅ 正确
                // 限流逻辑...
                break;
            // ...
        }
    }
}
```

##### 6.7.9.4 修改前后包名对照表

| 原包名 | 新包名 |
|--------|--------|
| `org.example.refundo.Util.JwtUtil` | 舍弃，使用`com.refund.framework.web.service.ApiTokenService` |
| `org.example.refundo.Util.JwtAuthenticationFilter` | 舍弃，使用`com.refund.framework.security.filter.ApiJwtAuthenticationFilter` |
| `org.example.refundo.Context.BaseContext` | 舍弃，使用`com.refund.common.utils.ApiSecurityUtils` |
| `org.example.refundo.Controller` | `com.refund.web.controller` |
| `org.example.refundo.Service` | `com.refund.web.service` |
| `org.example.refundo.Service.Impl` | `com.refund.web.service.impl` |
| `org.example.refundo.Aspect` | `com.refund.framework.aspectj` |
| `org.example.refundo.Config.SecurityConfig` | 合并到`com.refund.framework.config.SecurityConfig` |
| `org.example.refundo.Exception` | `com.refund.common.exception.business` |

##### 6.7.9.5 导入语句修改清单

**需要添加的导入（所有修改文件通用）：**
```java
import com.refund.common.utils.ApiSecurityUtils;
import com.refund.framework.web.service.ApiTokenService;
import com.refund.common.core.domain.model.ApiLoginUser;
```

**需要删除的导入（原APP端文件）：**
```java
import org.example.refundo.Context.BaseContext;
import org.example.refundo.Util.JwtUtil;
import org.example.refundo.Util.JwtAuthenticationFilter;
```

##### 6.7.9.6 修改统计汇总

| 统计项 | 数量 |
|--------|------|
| **需要修改的文件总数** | 11个 |
| **基础设施层文件** | 4个（2个舍弃，2个修改） |
| **Controller层文件** | 2个 |
| **Service层文件** | 4个（共12处修改） |
| **切面层文件** | 1个 |
| **BaseContext.getCurrentId()调用次数** | 12次 |
| **JwtUtil.generateToken()调用次数** | 1次 |
| **BaseContext.clear()调用次数** | 1次（需删除） |

---

## 七、返回结果类方案

### 7.1 结果类分离

| 结果类 | 用途 | 路径 |
|--------|------|------|
| **AjaxResult** | 管理系统返回结果 | `common/core/domain/AjaxResult.java` |
| **Result<T>** | APP端返回结果 | `common/core/domain/Result.java`（新增） |

### 7.2 Result类设计（APP端）

**文件位置**: `RefundO-common/src/main/java/com/refund/common/core/domain/Result.java`

```java
package com.refund.common.core.domain;

import java.io.Serializable;
import com.refund.common.utils.ApiMessageUtils;

/**
 * APP端统一返回结果类
 */
public class Result<T> implements Serializable {

    private static final long serialVersionUID = 1L;

    /** 状态码 */
    private Integer code;

    /** 返回数据 */
    private T data;

    /** 返回消息 */
    private String message;

    public Result() {
    }

    public Result(Integer code, T data, String message) {
        this.code = code;
        this.data = data;
        this.message = message;
    }

    /**
     * 成功返回
     */
    public static <T> Result<T> success() {
        return new Result<>(1, null, "success");
    }

    public static <T> Result<T> success(T data) {
        return new Result<>(1, data, "success");
    }

    public static <T> Result<T> success(String message) {
        return new Result<>(1, null, message);
    }

    public static <T> Result<T> success(String messageKey, Object... args) {
        String message = ApiMessageUtils.message(messageKey, args);
        return new Result<>(1, null, message);
    }

    /**
     * 失败返回
     */
    public static <T> Result<T> error() {
        return new Result<>(0, null, "error");
    }

    public static <T> Result<T> error(String message) {
        return new Result<>(0, null, message);
    }

    public static <T> Result<T> error(String messageKey, Object... args) {
        String message = ApiMessageUtils.message(messageKey, args);
        return new Result<>(0, null, message);
    }

    public static <T> Result<T> error(Integer code, String message) {
        return new Result<>(code, null, message);
    }

    // getter/setter...
}
```

---

## 八、数据库连接池方案

### 8.1 采用管理系统的Druid连接池

**舍弃APP端的HikariCP**，统一使用Druid

### 8.2 配置文件

**application-druid.yml**（保持现有）：

```yaml
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    druid:
      # 主库数据源
      master:
        url: jdbc:mysql://localhost:3306/ruoyi?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8
        username: root
        password: password
      # 初始连接数
      initialSize: 5
      # 最小连接池数量
      minIdle: 10
      # 最大连接池数量
      maxActive: 20
      # 配置获取连接等待超时的时间
      maxWait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位毫秒
      timeBetweenEvictionRunsMillis: 60000
      # 配置一个连接在池中最小生存的时间，单位毫秒
      minEvictableIdleTimeMillis: 300000
      # 配置一个连接在池中最大生存的时间，单位毫秒
      maxEvictableIdleTimeMillis: 900000
      # 配置检测连接是否有效
      validationQuery: SELECT 1
      testWhileIdle: true
      testOnBorrow: false
      testOnReturn: false
      webStatFilter:
        enabled: true
      statViewServlet:
        enabled: true
        urlPattern: /druid/*
        resetEnable: false
```

### 8.3 舍弃APP端的连接池配置

以下APP端配置类不需要迁移：
- `DataSourceConfig.java`
- `HikariPoolProperties.java`
- `HikariProxyDataSource.java`
- `ConnectionPoolMonitorService.java`

**替换为**：管理系统的 `DruidConfig.java`

---

## 九、过滤器链融合方案

### 9.1 融合后过滤器链

```
请求 → LocaleFilter → RateLimitFilter → RepeatableFilter → XssFilter → RefererFilter → ApiJwtFilter(仅/api) → JwtFilter → Controller
       [新增]        [新增]         [现有]        [现有]      [现有]        [新增-条件执行]      [现有]
```

### 9.2 SecurityConfig配置

**文件位置**: `RefundO-framework/src/main/java/com/refund/framework/config/SecurityConfig.java`

```java
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;

    @Autowired
    private ApiJwtAuthenticationFilter apiJwtAuthenticationTokenFilter;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // CSRF禁用
            .csrf().disable()
            // 无状态会话
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            // 权限配置
            .authorizeRequests()
                // 管理系统白名单
                .antMatchers("/login", "/register", "/captchaImage").permitAll()
                // APP端白名单
                .antMatchers("/api/user/login", "/api/user/signup",
                           "/api/user/forget", "/api/user/checkCode",
                           "/api/verification-code/**").permitAll()
                // 其他请求需要认证
                .anyRequest().authenticated()
            .and()
            // 过滤器链配置
            .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class)
            .addFilterBefore(apiJwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);

        // 禁用页面缓存
        http.headers().cacheControl();
    }
}
```

### 9.3 FilterConfig配置

**文件位置**: `RefundO-framework/src/main/java/com/refund/framework/config/FilterConfig.java`

```java
@Configuration
public class FilterConfig {

    /**
     * LocaleFilter - 最高优先级
     */
    @Bean
    public FilterRegistrationBean<LocaleFilter> localeFilterRegistration() {
        FilterRegistrationBean<LocaleFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new LocaleFilter());
        registration.addUrlPatterns("/*");
        registration.setOrder(1);
        registration.setName("localeFilter");
        return registration;
    }

    /**
     * RateLimitFilter - 第二优先级
     */
    @Bean
    public FilterRegistrationBean<RateLimitFilter> rateLimitFilterRegistration() {
        FilterRegistrationBean<RateLimitFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new RateLimitFilter());
        registration.addUrlPatterns("/api/*");  // 仅APP端需要限流
        registration.setOrder(2);
        registration.setName("rateLimitFilter");
        return registration;
    }

    // ... 保留现有其他过滤器配置 ...
}
```

---

## 十、异常类合并方案

### 10.1 异常类目录结构

```
RefundO-common/src/main/java/com/refund/common/exception/
├── base/
│   └── BaseException.java              # 保留
├── GlobalException.java                # 保留
├── ServiceException.java               # 保留
├── file/                               # 保留
├── user/                               # 保留
├── job/                                # 保留
└── business/                           # 新增业务异常包
    ├── AccountNotFoundException.java
    ├── AccountRepetitionException.java
    ├── AccountStatusErrorException.java
    ├── LoginLockedException.java
    ├── PasswordErrorException.java
    ├── CodeErrorException.java
    ├── ProductInvalidException.java
    ├── ProductRepetitionScanException.java
    ├── RefundRequestStatusException.java
    ├── RateLimitException.java
    └── EmailSendErrorException.java
```

### 10.2 异常类包名修改

```java
// APP端原始
package org.example.refundo.Exception;

// 修改为
package com.refund.common.exception.business;
```

---

## 十一、完整迁移步骤

### 阶段一：准备工作

```
1. 备份两个项目的Git仓库
2. 创建新的合并分支: git checkout -b merge-app-into-admin
3. 确保管理系统可以正常启动
```

### 阶段二：APP端代码降级

```
1. 修改APP端主pom.xml：
   - Spring Boot: 3.5.6 → 2.5.15
   - Java: 17 → 1.8
   - 全局替换 jakarta.* → javax.*
```

### 阶段三：工具类迁移

```
1. 迁移HmacUtil.java → common/utils/sign/
2. 迁移NumberGenUtils.java → common/utils/uuid/
3. 迁移PasswordUtil.java → common/utils/password/
4. 迁移RateLimitUtil.java → common/utils/ratelimit/
5. 修改包名为 com.refund.common.utils.xxx
```

### 阶段四：邮箱模块整合

```
1. 扩展EmailTemplate类
2. 扩展IMailService接口
3. 在MailServiceImpl中添加验证码发送方法
4. 添加Redis依赖注入
5. 测试验证码发送功能
```

### 阶段五：国际化配置

```
1. 创建ApiMessageUtils工具类
2. 创建ApiI18nConfig配置类
3. 修改HeaderLocaleResolver支持路径判断
4. 创建i18n/api-messages*.properties文件
5. 测试三语言切换
```

### 阶段六：JWT令牌配置

```
1. 创建ApiLoginUser类
2. 创建ApiTokenService类
3. 创建ApiJwtAuthenticationFilter类
4. 修改SecurityConfig配置
5. 添加application.yml配置
6. 测试令牌生成和解析
```

### 阶段七：返回结果类配置

```
1. 创建Result类
2. APP端Controller使用Result返回
3. 管理系统Controller继续使用AjaxResult
```

### 阶段八：过滤器配置

```
1. 迁移LocaleFilter
2. 迁移RateLimitFilter
3. 修改FilterConfig
4. 测试过滤器链执行顺序
```

### 阶段九：异常类迁移

```
1. 创建business包
2. 迁移APP端异常类
3. 修改GlobalExceptionHandler
4. 测试异常处理
```

### 阶段十：业务代码迁移

```
1. 迁移Controller层（/api前缀）
2. 迁移Service层
3. 迁移Mapper和XML
4. 使用OssUtil替换AliOssUtil
5. 测试API功能
```

### 阶段十一：测试与验证

```
1. 单元测试
2. 集成测试
3. 性能测试
4. 国际化测试
5. 安全测试
```

---

## 十二、配置文件总结

### application.yml 需要新增的配置

```yaml
# ========== APP端 Token配置 ==========
api:
  token:
    header: Authorization
    secret: abcdefghijklmnopqrstuvwxyz1234567890
    expireTime: 1440  # 24小时

# ========== 验证码配置 ==========
verification:
  code:
    expire-minutes: 3
    length: 6

# ========== 限流配置 ==========
rate:
  limit:
    enabled: true
    ip:
      time: 60
      count: 100
    login:
      time: 300
      count: 10
      fail-threshold: 5
      lock-duration: 30
    code:
      time: 60
      count: 5
```

---

## 十三、新增文件清单

| 文件路径 | 说明 |
|----------|------|
| `common/utils/sign/HmacUtil.java` | HMAC加密工具 |
| `common/utils/uuid/NumberGenUtils.java` | 数字生成工具 |
| `common/utils/password/PasswordUtil.java` | 密码加密工具 |
| `common/utils/ratelimit/RateLimitUtil.java` | 限流工具 |
| `common/utils/ApiMessageUtils.java` | APP端国际化工具 |
| `common/core/domain/Result.java` | APP端返回结果类 |
| `common/core/domain/model/ApiLoginUser.java` | APP端登录用户 |
| `common/exception/business/` | 业务异常包 |
| `common/filter/LocaleFilter.java` | 语言环境过滤器 |
| `common/filter/RateLimitFilter.java` | 限流过滤器 |
| `framework/config/ApiI18nConfig.java` | APP端国际化配置 |
| `framework/web/service/ApiTokenService.java` | APP端Token服务 |
| `framework/security/filter/ApiJwtAuthenticationFilter.java` | APP端JWT过滤器 |
| `admin/resources/i18n/api-messages*.properties` | APP端国际化文件 |

---

## 十四、总结

| 项目 | 状态 | 说明 |
|------|------|------|
| **Spring版本降级** | ✅ | APP端 3.5.6 → 2.5.15 |
| **Java版本** | ✅ | 17 → 1.8 |
| **HMAC/MD5独立** | ✅ | 两个工具类独立存在 |
| **邮箱模块整合** | ✅ | 验证码功能整合到MailService |
| **国际化分离** | ✅ | 路径前缀 + 独立上下文 |
| **JWT分离** | ✅ | 不同密钥 + 独立TokenService |
| **返回结果分离** | ✅ | AjaxResult vs Result |
| **数据库连接池** | ✅ | 统一使用Druid |
| **工具类迁移** | ✅ | 4个工具类迁移 |
| **异常类迁移** | ✅ | business包 |
| **过滤器融合** | ✅ | Locale + RateLimit + JWT |

---

**文档结束**
